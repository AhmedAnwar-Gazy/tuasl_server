package orgs.models2;

import orgs.utils.DatabaseConnection;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class Contact {
    private Long contactId; // Maps to 'id' INT AUTO_INCREMENT PRIMARY KEY in MySQL
    private Long ownerUserId; // Maps to 'user_id' in MySQL
    private Long contactUserId; // Maps to 'contact_user_id' in MySQL
    private String aliasName;
    private Timestamp addedAt; // Maps to 'created_at' in MySQL

    // Constructor for retrieving by ID
    public Contact(Long contactId) {
        this.contactId = contactId;
    }

    // Full constructor for creating/retrieving, matching the MySQL schema
    public Contact(Long contactId, Long ownerUserId, Long contactUserId, String aliasName, Timestamp addedAt) {
        this.contactId = contactId;
        this.ownerUserId = ownerUserId;
        this.contactUserId = contactUserId;
        this.aliasName = aliasName;
        this.addedAt = addedAt;
    }

    // Constructor for creating a new contact (ID will be auto-generated by DB)
    public Contact(Long ownerUserId, Long contactUserId, String aliasName) {
        this.ownerUserId = ownerUserId;
        this.contactUserId = contactUserId;
        this.aliasName = aliasName;
        // addedAt (created_at) is handled by DB default
    }

    // --- Getters and Setters ---
    public Long getContactId() {
        return contactId;
    }
    public void setContactId(Long contactId) {
        this.contactId = contactId;
    }

    public Long getOwnerUserId() {
        return ownerUserId;
    }
    public void setOwnerUserId(Long ownerUserId) {
        this.ownerUserId = ownerUserId;
    }

    public Long getContactUserId() {
        return contactUserId;
    }
    public void setContactUserId(Long contactUserId) {
        this.contactUserId = contactUserId;
    }

    public String getAliasName() {
        return aliasName;
    }
    public void setAliasName(String aliasName) {
        this.aliasName = aliasName;
    }

    public Timestamp getAddedAt() {
        return addedAt;
    }
    public void setAddedAt(Timestamp addedAt) {
        this.addedAt = addedAt;
    }

    // --- Database Operations ---

    /**
     * Saves a new contact record to the database.
     * The `created_at` timestamp is automatically handled by the database.
     *
     * @return true if the contact was successfully inserted, false otherwise.
     * @throws SQLException if a database access error occurs (e.g., duplicate contact entry).
     */
    public boolean save() throws SQLException {
        // SQL matching MySQL 'contacts' table columns ('user_id', 'contact_user_id', 'alias_name', 'created_at')
        // 'created_at' is omitted as it's handled by DB default
        String sql = "INSERT INTO contacts (user_id, contact_user_id, alias_name) VALUES (?, ?, ?)";

        try (Connection connection = DatabaseConnection.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            statement.setLong(1, ownerUserId);
            statement.setLong(2, contactUserId);
            statement.setString(3, aliasName);

            boolean isInserted = statement.executeUpdate() > 0;
            if (isInserted) {
                try (ResultSet generatedKeys = statement.getGeneratedKeys()) {
                    if (generatedKeys.next()) {
                        this.contactId = generatedKeys.getLong(1); // Set the auto-generated ID
                        // Optionally, fetch the addedAt (created_at) from DB if needed immediately after insert
                        // e.g., this.setAddedAt(findById(this.contactId).getAddedAt());
                    }
                }
            }
            return isInserted;
        }
    }

    /**
     * Updates the alias name for an existing contact record.
     * It identifies the record using the `contactId`.
     *
     * @return true if the contact was successfully updated, false otherwise.
     * @throws SQLException if a database access error occurs.
     */
    public boolean update() throws SQLException {
        String sql = "UPDATE contacts SET alias_name = ? WHERE id = ?"; // Use 'id' as per MySQL schema
        try (Connection connection = DatabaseConnection.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {

            statement.setString(1, aliasName);
            statement.setLong(2, contactId); // Use contactId for the WHERE clause (maps to 'id' in DB)

            return statement.executeUpdate() > 0;
        }
    }

    /**
     * Deletes a contact record from the database by its ID.
     *
     * @return true if the contact was successfully deleted, false otherwise.
     * @throws SQLException if a database access error occurs.
     */
    public boolean delete() throws SQLException {
        String sql = "DELETE FROM contacts WHERE id = ?"; // Use 'id' as per MySQL schema
        try (Connection connection = DatabaseConnection.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {

            statement.setLong(1, contactId); // Use contactId for the WHERE clause (maps to 'id' in DB)
            return statement.executeUpdate() > 0;
        }
    }

    // --- Retrieval Methods ---

    /**
     * Retrieves a contact record by its unique ID.
     *
     * @param id The ID of the contact record.
     * @return A Contact object if found, null otherwise.
     * @throws SQLException if a database access error occurs.
     */
    public static Contact findById(Long id) throws SQLException {
        String sql = "SELECT id, user_id, contact_user_id, alias_name, created_at FROM contacts WHERE id = ?";
        return executeQueryAndBuildContact(sql, id);
    }

    /**
     * Retrieves a specific contact entry by the owner user ID and the contact user ID.
     *
     * @param ownerUserId The ID of the user who owns this contact.
     * @param contactUserId The ID of the user who is the contact.
     * @return A Contact object if found, null otherwise.
     * @throws SQLException if a database access error occurs.
     */
    public static Contact findByOwnerAndContactUsers(Long ownerUserId, Long contactUserId) throws SQLException {
        String sql = "SELECT id, user_id, contact_user_id, alias_name, created_at FROM contacts WHERE user_id = ? AND contact_user_id = ?";
        return executeQueryAndBuildContact(sql, ownerUserId, contactUserId);
    }

    /**
     * Retrieves all contacts for a given owner user ID.
     *
     * @param ownerUserId The ID of the user whose contacts are to be retrieved.
     * @return A List of Contact objects.
     * @throws SQLException if a database access error occurs.
     */
    public static List<Contact> findByOwnerUserId(Long ownerUserId) throws SQLException {
        List<Contact> contacts = new ArrayList<>();
        String sql = "SELECT id, user_id, contact_user_id, alias_name, created_at FROM contacts WHERE user_id = ?";

        try (Connection connection = DatabaseConnection.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {
            statement.setLong(1, ownerUserId);
            try (ResultSet resultSet = statement.executeQuery()) {
                while (resultSet.next()) {
                    contacts.add(new Contact(
                            resultSet.getLong("id"),
                            resultSet.getLong("user_id"),
                            resultSet.getLong("contact_user_id"),
                            resultSet.getString("alias_name"),
                            resultSet.getTimestamp("created_at")
                    ));
                }
            }
        }
        return contacts;
    }

    /**
     * Helper method to execute a query and build a Contact object from the ResultSet.
     *
     * @param sql The SQL query to execute.
     * @param params The parameters for the PreparedStatement.
     * @return A Contact object or null.
     * @throws SQLException if a database access error occurs.
     */
    private static Contact executeQueryAndBuildContact(String sql, Object... params) throws SQLException {
        try (Connection connection = DatabaseConnection.getConnection();
             PreparedStatement statement = connection.prepareStatement(sql)) {

            for (int i = 0; i < params.length; i++) {
                if (params[i] instanceof Long) {
                    statement.setLong(i + 1, (Long) params[i]);
                } else if (params[i] instanceof String) {
                    statement.setString(i + 1, (String) params[i]);
                }
                // Add other types if necessary
            }

            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    return new Contact(
                            resultSet.getLong("id"),
                            resultSet.getLong("user_id"),
                            resultSet.getLong("contact_user_id"),
                            resultSet.getString("alias_name"),
                            resultSet.getTimestamp("created_at")
                    );
                }
            }
        }
        return null;
    }
}